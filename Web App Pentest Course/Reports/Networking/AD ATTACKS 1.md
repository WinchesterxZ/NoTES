# Kerberos User Enumeration Attack

## 1. Normal Behavior (How it works normally)
When a user wants to log in to the domain, they must first ask the Domain Controller (DC) for a ticket. This happens over **Port 88**.

- **Step 1 (AS-REQ):**  
  The user sends a message to the DC saying:  
  > "I am `ahmed.emad`, can I have a ticket?"

- **Step 2 (Validation):**  
  The DC checks its database:
  - Does this username exist?
  - Is the password correct?
- **Step 3:**  
  If everything is correct, the DC replies with a ticket.
## 2. The Exploit (Where is the weakness?)
The weakness is that Kerberos is too **honest** with its error messages.  
It gives a **different error** if the username exists vs. if it does not exist.

The attacker sends a request with a guessed username (e.g., `testuser`) **without a password**.

### Scenario A – User does NOT exist
- DC reply:  
  `KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN`
- Meaning: **Client not found**
- **Conclusion:** ❌ Username is invalid

### Scenario B – User DOES exist
- DC reply:  
  `KRB5KDC_ERR_PREAUTH_REQUIRED`
- Meaning: **Pre-authentication is required**
- **Conclusion:** ✅ **BINGO! Username is valid**
### The Tool: Kerbrute
Kerbrute automates this attack by sending thousands of usernames.  
If it receives the **Pre-Auth Required** error, it knows the user exists.
## 3. Attack Execution (Step-by-Step)

### The Problem
You know a real name (e.g., **Ahmed Tamer**) but not the username format:
- `ahmed.tamer`
- `a.tamer`
- `atamer`
- `ahmed-tamer`

### Step 1: Generate the Wordlist
Use a script to generate all possible username formats.

```bash
python namesh.py users.txt > allUsers.txt
```

**Output (`allUsers.txt`):**
```
ahmed.tamer
a.tamer
ahmed-tamer
atamer
... and so on
```

### Step 2: Run Kerbrute
Test the generated usernames against the Domain Controller.

```bash
./kerbrute_linux_amd64 userenum --dc 10.82.158.3 -d controller.local allUsers.txt
```

**Explanation:**
- `userenum` → User enumeration mode (safe, no account lockout)
- `--dc` → Domain Controller IP
- `-d` → Domain name
- `allUsers.txt` → Username wordlist

**Result:**  
![[Pasted image 20260109212248.png]]
## 4. Mitigation (How to fix it)

Stopping this attack completely is difficult because the DC must respond to Kerberos requests.  
The focus should be on **hardening** and **detection**.
### A. Hardening
- **Do not expose Port 88** to the internet  
  → Use VPN or internal-only access
### B. Detection (Most Important)
Monitor Windows Security Logs.

---
# Password Spraying Attack

## 1. Normal Behavior (How it works normally)
In a secure environment, Active Directory has a **Lockout Policy**.
* **Example:** If a user enters the wrong password **5 times** in 30 minutes, their account gets **locked**.
* This stops hackers from guessing thousands of passwords for one user (Brute Force).
## 2. The Exploit (Where is the weakness?)
The weakness is not in the software, but in the **human behavior** and the **logic of the Lockout Policy**.

* **Traditional Brute Force:** 1 User vs. 1000 Passwords. (Result: Account Locked ❌).
* **Password Spraying:** 1000 Users vs. 1 Password. (Result: No Lockout ✅).

The attacker takes **one common password** (like `Welcome2025` or `@Test1235`) and tries it once against every user. Since each user only has **one** failed login attempt, the account lockout counter never reaches the limit (e.g., 5).
## 3. Attack Execution (Step-by-Step)

**The Scenario:** You have a list of valid usernames (`valid_users.txt`) from the previous step (Enumeration). You suspect the password might be `@Test1235`.

**The Tool:** We use **NetExec (nxc)** (formerly CrackMapExec). It is excellent for testing credentials across a network using the SMB protocol.

**Command:**
```bash
nxc smb 10.82.158.3 -u valid_users.txt -p '@Test1235' --continue-on-success
```
Result: 
![[Pasted image 20260109213034.png]]
## 4. Mitigation (How to fix it)

### A. Prevention
1. **Strong Password Policy:** Ban common words (Company Name, "Password", "Summer", "Winter"). Use a "Password Filter" agent on the DC.
2. **Multi-Factor Authentication (MFA):** Even if the attacker guesses the password, they cannot login without the phone code.
3. **Fine-Grained Password Policies:** Apply stricter rules for admins.
### B. Detection
This is harder to detect than Brute Force because there are no lockouts.
- **Monitor Event ID:** **4625** (An account failed to log on).
- **The Pattern:** Look for a **spike** in 4625 events happening to **many different usernames** originating from the **same IP address** within a few seconds.

# LLMNR/NBT-NS Poisoning (With SMB Signing Enabled)

## 1. Normal Behavior (How it works normally)
When a user wants to access a shared folder (e.g., `\\PrintServer`), the computer needs to find the IP address of that name.
It follows this order:
1.  **Local Hosts File:** Checks its own memory.
2.  **DNS (Domain Name System):** Asks the DNS server (The standard way).
3.  **LLMNR (Link-Local Multicast Name Resolution):** If DNS fails (e.g., the user typed `\\PrntSrvr` by mistake), the computer "shouts" to the whole local network: *"Hey, does anyone know the IP of PrntSrvr?"*
4.  **NBT-NS (NetBIOS Name Service):** The old version of LLMNR (same concept).
## 2. The Exploit (Where is the weakness?)
The weakness is that LLMNR and NBT-NS are **unauthenticated broadcast protocols**. The computer trusts *anyone* who answers.

* **The Scenario:** A victim makes a typo (e.g., `\\Server01` -> `\\Server001`).
* **DNS:** Says "I don't know this name."
* **LLMNR Broadcast:** The victim shouts: "Who is Server001?"
* **The Attacker (Poisoner):** Immediately answers: "I am Server001! Send me your credentials to connect."
* **The Capture:** The victim believes the attacker and sends their **NTLMv2 Hash** (Encrypted Password).
## 3. Attack Execution (Step-by-Step)

**The Tool:** **Responder**. It listens for these "shouts" and automatically lies to the victims to steal hashes.

**Command:**
```bash
sudo responder -I eth0 -dwv
```

## 4. Mitigation (How to fix it)
### A. Disable LLMNR & NBT-NS 
Since DNS is the standard now, you don't need these old protocols.
1. **Disable LLMNR (Group Policy):**
    - Go to: `Computer Configuration > Administrative Templates > Network > DNS Client`.
    - Set **"Turn off multicast name resolution"** to **Enabled**.
2. **Disable NBT-NS:**
    - This is usually done via DHCP options or manually in network adapter settings (WINS tab > Disable NetBIOS over TCP/IP).

# AS-REP Roasting Attack

## 1. Normal Behavior (How it works normally)
In the standard Kerberos process (which we discussed in the first attack), the DC wants to verify you **before** it gives you a ticket.

* **Pre-Authentication:** The user sends a Timestamp encrypted with their Password Hash.
* **The DC Check:** The DC decrypts the timestamp. If it works, it proves the user knows the password.
* **Result:** Only *then* does the DC send the Ticket (TGT).
## 2. The Exploit (Where is the weakness?)
The weakness exists if an administrator has enabled a specific setting on a user account: **"Do not require Kerberos preauthentication"**.

* **The Scenario:** You ask the DC: "I am user `ServiceAccount`, give me a ticket."
* **The Problem:** Because Pre-Auth is **disabled**, the DC does *not* ask for your password or timestamp first.
* **The Leak:** The DC immediately replies: "Okay! Here is your ticket."
* **The Catch:** Part of that ticket is encrypted with the user's password.
* **The Attack:** You take that encrypted part (the AS-REP), go offline, and try to brute-force it until you find the password that decrypts it.
## 3. Attack Execution (Step-by-Step)

### Method A: From Linux (Impacket)
This is useful if you are outside the domain but have a list of usernames (`valid_users.txt`).

**Command:**
```bash
impacket-GetNPUsers controller.local/ -dc-ip 10.82.158.3 -usersfile valid_users.txt -format john -outputfile crackme.txt -no-pass -request
```

```
impacket-GetNPUsers fusion.corp/lparker -dc-ip 10.81.171.71 -no-pass -request -format john -outputfile crackme.txt
```


![[Pasted image 20260109213807.png]]
### Method B: From Windows (Rubeus)

```powershell
C:\Users\Administrator\Desktop\Rubeus.exe asreproast /nowrap
```
- `asreproasts`: Tells Rubeus to query LDAP for any user with the "No Pre-Auth" flag set and ask for their ticket.
- `/nowrap`: Makes the output easier to copy/paste (keeps the hash on one line).
![[Pasted image 20260109214906.png]]
then You can crack it 
![[Pasted image 20260109214937.png]]
## 4. Mitigation (How to fix it)

This is a misconfiguration, not a bug.
1. **Audit Users:** Check your Active Directory for accounts with `DONT_REQ_PREAUTH` enabled.
    - _PowerShell:_ `Get-ADUser -Filter {DoesNotRequirePreAuth -eq $True} -Properties DoesNotRequirePreAuth`
2. **Enable Pre-Auth:** Go to the user properties in AD > "Account" tab > **Uncheck** "Do not require Kerberos preauthentication".
# Kerberoasting Attack

## 1. Normal Behavior (How it works normally)
Once a user has a **TGT** (Ticket Granting Ticket) – which we got in step 1 – they can ask for access to specific services (like SQL Server, IIS, or File Shares).

* **Step 1 (TGS-REQ):** The user tells the DC: "I have a valid TGT. Please give me a ticket to talk to the SQL Server (`MSSQLSvc/db.controller.local`)."
* **Step 2 (TGS-REP):** The DC checks the TGT. If valid, it creates a **Service Ticket (TGS)**.
* **The Key Detail:** The DC encrypts this ticket using the **Service Account's Password Hash**. This is done so that only the SQL Server (which knows its own password) can decrypt and read the ticket.
## 2. The Exploit (Where is the weakness?)
The weakness is that the DC does not check if you *should* have access to the service before giving you the ticket. It assumes the Service itself will make that decision later.

* **The Problem:** Any valid user can request a ticket for **ANY** service in the domain.
* **The Attack:**
    1.  You ask for a ticket for a Service Account.
    2.  The DC gives you the ticket (encrypted with the Service Account's password).
    3.  You take that ticket offline.
    4.  You try millions of passwords until one successfully decrypts the ticket.
    5.  **Result:** You now have the clear-text password of that Service Account. (If that account is a Domain Admin, you own the network).
## 3. Attack Execution (Step-by-Step)

**The Tool:** **Impacket (GetUserSPNs)**. This tool searches the domain for user accounts that are linked to services (SPNs) and asks for their tickets.

**Command:**
```bash
impacket-GetUserSPNs controller.local/Administrator:'P@$$W0rd' -dc-ip 10.66.163.23 -request -format john -outputfile serviceHash.txt
```


```
impacket-GetUserSPNs $domain/lvetrova -hashes aad3b435b51404eeaad3b435b51404ee:f220d3988deb3f516c73f40ee16c431d -dc-ip $IP -request -outputfile serviceHash.txt
```

![[Pasted image 20260109215323.png]]
## 4. Mitigation (How to fix it)
- **Long Passwords:** Service Accounts (e.g., SQL_Service) must have long, complex passwords (25+ characters).
    
- **Managed Service Accounts (gMSA):** Use "Group Managed Service Accounts". Windows manages these passwords automatically (120 characters, changed every 30 days), making them impossible to crack.
    
- **AES Encryption:** Force the domain to use AES encryption instead of RC4 (RC4 is easier to crack).

