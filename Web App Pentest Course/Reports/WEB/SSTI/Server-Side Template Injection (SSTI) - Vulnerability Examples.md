# Server-Side Template Injection (SSTI) - Vulnerability Examples

Below are 4 code examples demonstrating how SSTI occurs in different languages and frameworks, analyzing the Source, Sink, and logic, followed by the mitigation strategy.

---

## 1. Python (Flask + Jinja2)
### Vulnerable Code
```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/hello')
def hello():
    name = request.args.get('name') # Source
    # Direct concatenation of input into the template string
    template = "<h1>Hello " + name + "</h1>"
    return render_template_string(template) # Sink
    ````

- **Source:** `request.args.get('name')` - Receives untrusted data.
    
- **Sink:** `render_template_string(template)` - Renders the string as Jinja2 code.
    
- **Basic Logic:** Because the variable `name` is merged _inside_ the string before the engine sees it, any Jinja syntax (like `{{7*7}}`) passed by the user gets executed.
## 2. Node.js (Express + Pug/Jade)

Here, the vulnerability occurs when the developer builds the template string dynamically using string interpolation before passing it to the render function.

### Vulnerable Code
```javascript
const express = require('express');
const pug = require('pug');
const app = express();

app.get('/', (req, res) => {
    const userInput = req.query.name; // Source
    // Constructing the template via string interpolation
    const template = `h1 Welcome ${userInput}`;
    const html = pug.render(template); // Sink
    res.send(html);
});
```
- **Source:** `req.query.name`.
    
- **Sink:** `pug.render(template)`.
    
- **Basic Logic:** The developer treats the template as a standard string first. If the attacker sends Pug-specific code, the engine executes it during the render phase.

## 3. PHP (Smarty)

Smarty is a popular PHP template engine. The vulnerability often arises when using the `string:` or `eval:` resource types within the display function.

### Vulnerable Code
```php
require('Smarty.class.php');
$smarty = new Smarty();

$user_input = $_GET['data']; // Source

// Using 'string:' tells Smarty to treat the variable content as a template
$smarty->display('string:' . $user_input); // Sink
```

- **Source:** `$_GET['data']`.
    
- **Sink:** `$smarty->display('string:...')`.
    
- **Basic Logic:** The `string:` prefix forces Smarty to parse and evaluate the content of `$user_input` as template code rather than just text.

## 4. Ruby (ERB)

ERB is the standard templating system for Ruby.

### Vulnerable Code
```ruby
require 'erb'

# Source: receiving input (hypothetical params example)
user_input = params[:name] 

# Concatenating input directly into the template code
template = "Welcome to our site, <%= " + user_input + " %>"

# Sink: Creating and running the template
renderer = ERB.new(template)
puts renderer.result
```

- **Source:** `params[:name]`.
    
- **Sink:** `ERB.new(template)`.
    
- **Basic Logic:** The input is placed directly inside the execution tags `<%= %>` during template construction, allowing arbitrary Ruby code execution.

## Mitigation (How to Fix)

The golden rule to prevent SSTI is: **Never concatenate user input directly into the template string.**

Instead, pass the data as **Context** or **Variables** to the template engine. This ensures the engine treats the input as data (text) rather than executable code.

### Secure Example (Python/Flask)
```python
# Secure Code
@app.route('/hello')
def hello():
    name = request.args.get('name')
    # Pass the variable as an argument, do not merge it into the string
    return render_template_string("<h1>Hello {{ user_name }}</h1>", user_name=name)
```
 The Jinja2 engine places the value of `name` into the `{{ user_name }}` placeholder and automatically handles **Escaping**, rendering it as harmless text.